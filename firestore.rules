/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model centered
 * around doctors. All clinical data (patients, clients, examinations) is nested
 * under a doctor's unique ID, making them the sole owner of that data tree.
 * Public reference data, like medications and diseases, is globally readable.
 *
 * Data Structure: The primary data is organized hierarchically under the
 * `/doctors/{doctorId}` path. This structure ensures that a doctor's data is
 * logically grouped and can be secured efficiently using path-based rules.
 * Global lookup data (`/medications`, `/diseases`) is stored in separate,
 * top-level collections for easy public access.
 *
 * Key Security Decisions:
 * - Strict Ownership: Only the authenticated doctor whose UID matches the
 *   `{doctorId}` in the path can access or modify the data within that path.
 * - No User Enumeration: Listing the top-level `/doctors` collection is
 *   disallowed to protect doctor privacy.
 * - Public Read-Only Collections: `/medications` and `/diseases` are readable
 *   by anyone (including unauthenticated users) but are not writable. This
 *   prevents unauthorized modification of shared clinic data.
 * - Path-Data Consistency: On creation, rules validate that the document's
 *   internal `id` field matches the document ID from the path, ensuring
 *   relational integrity.
 *
 * Denormalization for Authorization: The data model is inherently designed for
 * efficient authorization. By nesting all patient-related data under a doctor's
 * ID, the rules can authorize access simply by checking the `doctorId` in the
 * path against the user's `request.auth.uid`. This avoids costly and slow `get()`
 * calls to other documents for permission checks.
 *
 * Structural Segregation: The ruleset leverages structural segregation by
 * separating private doctor/patient data (`/doctors/{doctorId}/...`) from public
 * reference data (`/medications`, `/diseases`). This separation simplifies rules,
 * improves query performance, and enhances security by applying different
 * access control patterns to different data types.
 */
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ---------------------------
    // Helper Functions
    // ---------------------------

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for verifying document ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * A robust check for update/delete operations, ensuring the document exists
     * before checking for ownership. This prevents unauthorized actions on
     * non-existent paths.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // ---------------------------
    // Collection Rules
    // ---------------------------

    /**
     * @description Controls access to doctor profiles. A doctor can create their own profile,
     *              and only they can read, update, or delete it.
     * @path /doctors/{doctorId}
     * @allow (create) An authenticated user (uid: 'doctor_abc') creates their own profile at '/doctors/doctor_abc'.
     * @deny  (get) A user ('doctor_xyz') tries to read the profile of another doctor at '/doctors/doctor_abc'.
     * @principle Enforces strict document ownership and self-creation for user profiles.
     */
    match /doctors/{doctorId} {
      allow get: if isOwner(doctorId);
      allow list: if false; // Prevent enumeration of all doctors for privacy
      allow create: if isOwner(doctorId) && request.resource.data.id == doctorId;
      allow update: if isExistingOwner(doctorId);
      allow delete: if isExistingOwner(doctorId);

      /**
       * @description Controls access to patient records, which are owned by a specific doctor.
       * @path /doctors/{doctorId}/patients/{patientId}
       * @allow (create) The owning doctor ('doctor_abc') creates a new patient record under their own path.
       * @deny  (list) A different doctor ('doctor_xyz') tries to list patients for 'doctor_abc'.
       * @principle Path-based ownership: Access is inherited from the parent doctor's path.
       */
      match /patients/{patientId} {
        allow get: if isOwner(doctorId);
        allow list: if isOwner(doctorId);
        allow create: if isOwner(doctorId);
        allow update: if isExistingOwner(doctorId);
        allow delete: if isExistingOwner(doctorId);

        /**
         * @description Controls access to client (owner) records associated with a patient.
         * @path /doctors/{doctorId}/patients/{patientId}/clients/{clientId}
         * @allow (get) The owning doctor ('doctor_abc') reads a client record for one of their patients.
         * @deny  (update) A different doctor ('doctor_xyz') tries to update a client record.
         * @principle Path-based ownership: Access is inherited from the parent doctor's path.
         */
        match /clients/{clientId} {
          allow get: if isOwner(doctorId);
          allow list: if isOwner(doctorId);
          allow create: if isOwner(doctorId);
          allow update: if isExistingOwner(doctorId);
          allow delete: if isExistingOwner(doctorId);
        }

        /**
         * @description Controls access to patient health status records.
         * @path /doctors/{doctorId}/patients/{patientId}/presentStatuses/{presentStatusId}
         * @allow (list) The owning doctor ('doctor_abc') lists all status updates for a patient.
         * @deny  (create) A different doctor ('doctor_xyz') tries to add a new status record.
         * @principle Path-based ownership: Access is inherited from the parent doctor's path.
         */
        match /presentStatuses/{presentStatusId} {
          allow get: if isOwner(doctorId);
          allow list: if isOwner(doctorId);
          allow create: if isOwner(doctorId);
          allow update: if isExistingOwner(doctorId);
          allow delete: if isExistingOwner(doctorId);
        }

        /**
         * @description Controls access to patient examination records.
         * @path /doctors/{doctorId}/patients/{patientId}/examinations/{examinationId}
         * @allow (delete) The owning doctor ('doctor_abc') deletes an old examination record.
         * @deny  (get) An anonymous user tries to read an examination record.
         * @principle Path-based ownership: Access is inherited from the parent doctor's path.
         */
        match /examinations/{examinationId} {
          allow get: if isOwner(doctorId);
          allow list: if isOwner(doctorId);
          allow create: if isOwner(doctorId);
          allow update: if isExistingOwner(doctorId);
          allow delete: if isExistingOwner(doctorId);
        }
      }
    }

    /**
     * @description Manages the global list of medications. This data is public to read
     *              for all users, but write access is disabled to protect data integrity.
     * @path /medications/{medicationId}
     * @allow (list) Any user (authenticated or not) can list all available medications.
     * @deny  (create) Any user tries to add a new medication to the list.
     * @principle Public read-only data. Writes are disabled for security until an admin role is defined.
     */
    match /medications/{medicationId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages the global list of diseases. This data is public to read
     *              for all users, but write access is disabled to protect data integrity.
     * @path /diseases/{diseaseId}
     * @allow (get) Any user (authenticated or not) can read the details of a specific disease.
     * @deny  (update) Any user tries to modify a disease description.
     * @principle Public read-only data. Writes are disabled for security until an admin role is defined.
     */
    match /diseases/{diseaseId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}